#!/usr/bin/env python3
"""Regenerate the README category tables from markdown files in `categories/`.

Usage::

    python scripts/build_readme.py

The script parses each category file, extracts tool metadata, and rewrites the
section between the README markers `START_AUTOGENERATED_TABLES` and
`END_AUTOGENERATED_TABLES`.
"""
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from typing import List

ROOT = Path(__file__).resolve().parents[1]
README_PATH = ROOT / "README.md"

MARKER_START = "<!-- START_AUTOGENERATED_TABLES -->"
MARKER_END = "<!-- END_AUTOGENERATED_TABLES -->"


@dataclass
class ToolEntry:
    name: str
    website: str
    tags: List[str]
    license: str
    overview: str
    update_pulse: str
    use_cases: List[str]


CATEGORY_DEFS = [
    ("Image Generation", Path("categories/image-generation.md")),
    ("Video & Animation", Path("categories/video-animation.md")),
    ("Music & Audio", Path("categories/music-audio.md")),
    ("3D & Spatial", Path("categories/3d-spatial.md")),
    ("Avatars & VTubing", Path("categories/avatars-vtubing.md")),
    ("Creative Coding & Workflows", Path("categories/creative-coding-workflows.md")),
    ("Collaboration Tools", Path("categories/collaboration-tools.md")),
    ("Multi-Modal Systems", Path("categories/multi-modal-systems.md")),
    ("Evaluation & Control", Path("categories/evaluation-control.md")),
    ("Datasets, Stock & Training", Path("categories/datasets-training.md")),
]


def parse_category_file(path: Path) -> List[ToolEntry]:
    content = path.read_text(encoding="utf-8")
    sections = re.split(r"\n## ", content)
    entries: List[ToolEntry] = []

    # first split chunk is material before the first tool heading
    for raw_section in sections[1:]:
        lines = raw_section.strip().splitlines()
        if not lines:
            continue
        name = lines[0].strip()

        website = ""
        tags: List[str] = []
        license_field = ""
        overview = ""
        update_pulse = "—"
        use_cases: List[str] = []

        i = 1
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            if line.startswith("- **Website:**"):
                value = line.split("**Website:**", 1)[1].strip()
                website = value.strip().strip("<>")
            elif line.startswith("- **Tags:**"):
                value = line.split("**Tags:**", 1)[1].strip()
                tags = [tag.strip() for tag in value.split(",") if tag.strip()]
            elif line.startswith("- **License:**"):
                license_field = line.split("**License:**", 1)[1].strip()
            elif line.startswith("- **Overview:**"):
                overview = line.split("**Overview:**", 1)[1].strip()
            elif line.startswith("- **Use Cases:**"):
                i += 1
                while i < len(lines):
                    sub_line = lines[i]
                    if sub_line.startswith('  - '):
                        case = sub_line[4:].strip()
                        use_cases.append(case)
                        i += 1
                    else:
                        break
                continue
            elif line.startswith("- **Update Pulse:**"):
                update_pulse = line.split("**Update Pulse:**", 1)[1].strip()
            i += 1

        if not website:
            raise ValueError(f"Missing website for tool '{name}' in {path}")
        if not overview:
            raise ValueError(f"Missing overview for tool '{name}' in {path}")
        entries.append(
            ToolEntry(
                name=name,
                website=website,
                tags=tags,
                license=license_field,
                overview=overview,
                update_pulse=update_pulse,
                use_cases=use_cases,
            )
        )

    return entries


def build_table(entries: List[ToolEntry]) -> List[str]:
    table_lines = [
        "| Tool | Description | Tags | License | Update Pulse | Use Cases |",
        "| --- | --- | --- | --- | --- | --- |",
    ]
    for entry in entries:
        tags_str = ", ".join(f"`{tag}`" for tag in entry.tags) if entry.tags else "—"
        use_cases_str = "; ".join(entry.use_cases) if entry.use_cases else "—"
        row = (
            f"| [{entry.name}]({entry.website}) | {entry.overview} | {tags_str} | "
            f"{entry.license or '—'} | {entry.update_pulse or '—'} | {use_cases_str} |"
        )
        table_lines.append(row)
    return table_lines


def build_sections() -> str:
    blocks: List[str] = []
    for display_name, rel_path in CATEGORY_DEFS:
        abs_path = ROOT / rel_path
        if not abs_path.exists():
            raise FileNotFoundError(f"Missing category file: {rel_path}")
        entries = parse_category_file(abs_path)
        section_lines = [
            f"## {display_name}",
            f"> Full entry template lives in `{rel_path.as_posix()}`.",
            "",
            *build_table(entries),
            "",
        ]
        blocks.append("\n".join(section_lines).rstrip())
    return "\n\n".join(blocks)


def update_readme(generated: str) -> None:
    original = README_PATH.read_text(encoding="utf-8")
    if MARKER_START not in original or MARKER_END not in original:
        raise RuntimeError("README markers missing; cannot inject generated tables.")

    before, rest = original.split(MARKER_START, 1)
    middle, after = rest.split(MARKER_END, 1)

    replacement = (
        f"{MARKER_START}\n<!-- This section is auto-generated by scripts/build_readme.py. -->\n"
        f"{generated.strip()}\n{MARKER_END}"
    )
    updated = before + replacement + after
    README_PATH.write_text(updated, encoding="utf-8")


def main() -> None:
    generated = build_sections()
    update_readme(generated)
    print("README tables regenerated.")


if __name__ == "__main__":
    main()
